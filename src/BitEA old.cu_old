#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <curand_kernel.h>

#include "BitEA.h"
#include "stdgraph.h"

const int _graph_size = 1024; // graph_size;
__device__ curandState *curand_state;

__global__ void setup_kernel(unsigned long seed)
{
    int id = threadIdx.x;
    curand_init(seed, id, 0, &curand_state[id]);
}

int BitEA(int graph_size, const block_t *edges, int *weights, int population_size, int base_color_count, int max_gen_num, block_t *best_solution, int *best_fitness, float *best_solution_time, int *uncolored_num)
{
    // Create the random population.
    block_t *population[population_size];
    int color_count[population_size];
    int uncolored[population_size];
    int fitness[population_size];
    for (int i = 0; i < population_size; i++)
    {
        population[i] = (block_t *)calloc(base_color_count * TOTAL_BLOCK_NUM((size_t)graph_size), sizeof(block_t));
        uncolored[i] = base_color_count;
        color_count[i] = base_color_count;
        fitness[i] = __INT_MAX__;
    }

    cudaMalloc((void **)&curand_state, sizeof(curandState));
    setup_kernel<<<1, 1>>>(time(NULL)); // Setting up the kernel

    pop_complex_random(graph_size, edges, weights, population_size, population, base_color_count);

    struct timeval t1, t2;
    *best_solution_time = 0;
    gettimeofday(&t1, NULL);

    block_t *child = (block_t *)malloc(base_color_count * TOTAL_BLOCK_COUNT * sizeof(block_t));
    int best_i = 0;
    int target_color = base_color_count;
    int temp_uncolored;
    int parent1, parent2, child_colors, temp_fitness;
    int bad_parent;
    for (int i = 0; i < 1; i++)
    {
        if (target_color == 0)
            break;

        // Initialize the child
        memset(child, 0, (TOTAL_BLOCK_COUNT)*base_color_count * sizeof(block_t));

        // Pick 2 random parents
        parent1 = rand() % population_size;
        do
        {
            parent2 = rand() % population_size;
        } while (parent2 != parent1);

        // Do a crossover
        temp_fitness = crossover(graph_size, edges, weights, color_count[parent1], color_count[parent2], population[parent1], population[parent2], target_color, child, &child_colors, &temp_uncolored);

        // Choose the bad parent.
        if (fitness[parent1] <= fitness[parent2] && color_count[parent1] <= color_count[parent2])
            bad_parent = parent2;
        else
            bad_parent = parent1;

        // Replace the bad parent if needed.
        if (child_colors <= color_count[bad_parent] && temp_fitness <= fitness[bad_parent])
        {
            memmove(population[bad_parent], child, (TOTAL_BLOCK_COUNT)*base_color_count * sizeof(block_t));
            color_count[bad_parent] = child_colors;
            fitness[bad_parent] = temp_fitness;
            uncolored[bad_parent] = temp_uncolored;

            if (temp_fitness < fitness[best_i] ||
                (temp_fitness == fitness[best_i] && child_colors < color_count[best_i]))
            {
                best_i = bad_parent;
                gettimeofday(&t2, NULL);
                *best_solution_time = (t2.tv_sec - t1.tv_sec) + (t2.tv_usec - t1.tv_usec) / 1000000.0; // us to ms
            }
        }

        // Make the target harder if it was found.
        if (temp_fitness == 0)
            target_color = child_colors - 1;
    }

    // Return the best solution
    *best_fitness = fitness[best_i];
    *uncolored_num = uncolored[best_i];
    memcpy(best_solution, population[best_i], base_color_count * (TOTAL_BLOCK_COUNT) * sizeof(block_t));

    // Free allocated space.
    free(child);
    for (int i = 0; i < population_size; i++)
        free(population[i]);

    return color_count[best_i];
}

__device__ int get_rand_color(int max_color_num, int colors_used, block_t used_color_list[])
{
    // There are no available colors.
    if (colors_used >= max_color_num)
    {
        return -1;

        // There are only 2 colors available, search for them linearly.
    }
    else if (colors_used > max_color_num - 2)
    {
        for (int i = 0; i < max_color_num; i++)
        {
            if (!(used_color_list[BLOCK_INDEX(i)] & MASK(i)))
            {
                used_color_list[BLOCK_INDEX(i)] |= MASK(i);
                return i;
            }
        }
    }

    // Randomly try to select an available color.
    int temp;
    while (1)
    {
        temp = curand(curand_state) % max_color_num;
        if (!(used_color_list[BLOCK_INDEX(temp)] & MASK(temp)))
        {
            used_color_list[BLOCK_INDEX(temp)] |= MASK(temp);
            return temp;
        }
    }
}

__device__ void fix_conflicts(int graph_size, const block_t *edges, const int *weights, int *conflict_count, int *total_conflicts, block_t *color, block_t *pool, int *pool_total)
{
    block_t(*edges_p)[][TOTAL_BLOCK_COUNT - 1] = (block_t(*)[][TOTAL_BLOCK_COUNT - 1]) edges;

    // Keep removing problematic vertices until all conflicts are gone.
    int i, worst_vert = 0, vert_block;
    block_t vert_mask;
    while (*total_conflicts > 0)
    {
        // Find the vertex with the most conflicts.
        for (i = 0; i < _graph_size; i++)
        {
            if (CHECK_COLOR(color, i) &&
                (conflict_count[worst_vert] < conflict_count[i] ||
                 (conflict_count[worst_vert] == conflict_count[i] &&
                  (weights[worst_vert] > weights[i] || (weights[worst_vert] == weights[i] && curand(curand_state) % 2)))))
            {
                worst_vert = i;
            }
        }

        // Update other conflict counters.
        vert_mask = MASK(worst_vert);
        vert_block = BLOCK_INDEX(worst_vert);
        for (i = 0; i < _graph_size; i++)
            if (CHECK_COLOR(color, i) && ((*edges_p)[i][vert_block] & vert_mask))
                conflict_count[i]--;

        // Remove the vertex.
        color[vert_block] &= ~vert_mask;
        pool[vert_block] |= vert_mask;
        (*pool_total)++;

        // Update the total number of conflicts.
        (*total_conflicts) -= conflict_count[worst_vert];
        conflict_count[worst_vert] = 0;
    }
}

__device__ int __popcountl(uint64_t n)
{
    int cnt = 0;
    while (n)
    {
        n &= n - 1; // key point
        ++cnt;
    }
    return cnt;
}

__device__ int count_conflicts(int graph_size, const block_t *color, const block_t *edges, int *conflict_count)
{
    block_t(*edges_p)[][TOTAL_BLOCK_COUNT - 1] = (block_t(*)[][TOTAL_BLOCK_COUNT - 1]) edges;

    int i, j, total_conflicts = 0;
    for (i = 0; i < _graph_size; i++)
    {
        if (CHECK_COLOR(color, i))
        {
            conflict_count[i] = 0;
            for (j = 0; j < TOTAL_BLOCK_COUNT; j++)
                conflict_count[i] += __popcountl(color[j] & (*edges_p)[i][j]);
            total_conflicts += conflict_count[i];
        }
    }

    return total_conflicts / 2;
}

__device__ void merge_and_fix(int graph_size, const block_t *edges, const int *weights, const block_t **parent_color, block_t *child_color, block_t *pool, int *pool_count, block_t *used_vertex_list, int *used_vertex_count)
{
    // Merge the two colors
    int temp_v_count = 0;
    if (parent_color[0] != NULL && parent_color[1] != NULL)
        for (int i = 0; i < (TOTAL_BLOCK_COUNT); i++)
        {
            child_color[i] = ((parent_color[0][i] | parent_color[1][i]) & ~(used_vertex_list[i]));
            temp_v_count += __popcountl(child_color[i]);
        }

    else if (parent_color[0] != NULL)
        for (int i = 0; i < (TOTAL_BLOCK_COUNT); i++)
        {
            child_color[i] = (parent_color[0][i] & ~(used_vertex_list[i]));
            temp_v_count += __popcountl(child_color[i]);
        }

    else if (parent_color[1] != NULL)
        for (int i = 0; i < (TOTAL_BLOCK_COUNT); i++)
        {
            child_color[i] = (parent_color[1][i] & ~(used_vertex_list[i]));
            temp_v_count += __popcountl(child_color[i]);
        }

    (*used_vertex_count) += temp_v_count;

    // Merge the pool with the new color
    for (int i = 0; i < (TOTAL_BLOCK_COUNT); i++)
    {
        child_color[i] |= pool[i];
        used_vertex_list[i] |= child_color[i];
    }

    memset(pool, 0, (TOTAL_BLOCK_COUNT) * sizeof(block_t));
    (*pool_count) = 0;

    // List of conflict count per vertex.
    int conflict_count[_graph_size];
    memset(conflict_count, 0, graph_size * sizeof(int));

    // Count conflicts.
    int total_conflicts = count_conflicts(graph_size, child_color, edges, conflict_count);

    // Fix the conflicts.
    fix_conflicts(graph_size, edges, weights, conflict_count, &total_conflicts, child_color, pool, pool_count);
}

__device__ void search_back(int graph_size, const block_t *edges, const int *weights, block_t *child, int color_count, block_t *pool, int *pool_count)
{
    block_t(*edges_p)[][TOTAL_BLOCK_COUNT - 1] = (block_t(*)[][TOTAL_BLOCK_COUNT - 1]) edges;
    block_t(*child_p)[][TOTAL_BLOCK_COUNT - 1] = (block_t(*)[][TOTAL_BLOCK_COUNT - 1]) child;

    int conflict_count, last_conflict, last_conflict_block = 0;
    block_t i_mask, temp_mask, last_conflict_mask = 0;
    int i, j, k, i_block;

    // Search back and try placing vertices from the pool in previous colors.
    for (i = 0; i < graph_size && (*pool_count) > 0; i++)
    {
        i_block = BLOCK_INDEX(i);
        i_mask = MASK(i);

        // Check if the vertex is in the pool.
        if (pool[i_block] & i_mask)
        {
            // Loop through every previous color.
            for (j = 0; j < color_count; j++)
            {
                // Count the possible conflicts in this color.
                conflict_count = 0;
                for (k = 0; k < TOTAL_BLOCK_COUNT; k++)
                {
                    temp_mask = (*child_p)[j][k] & (*edges_p)[i][k];
                    if (temp_mask)
                    {
                        conflict_count += __popcountl(temp_mask);
                        if (conflict_count > 1)
                            break;
                        last_conflict = sizeof(block_t) * 8 * (k + 1) - 1 - __clzll(temp_mask);
                        last_conflict_mask = temp_mask;
                        last_conflict_block = k;
                    }
                }

                // Place immediately if there are no conflicts.
                if (conflict_count == 0)
                {
                    (*child_p)[j][i_block] |= i_mask;
                    pool[i_block] &= ~i_mask;
                    (*pool_count)--;
                    break;

                    // If only 1 conflict exists and its weight is smaller
                    // than that of the vertex in question, replace it.
                }
                else if (conflict_count == 1 && weights[last_conflict] < weights[i])
                {
                    (*child_p)[j][i_block] |= i_mask;
                    pool[i_block] &= ~i_mask;

                    (*child_p)[j][last_conflict_block] &= ~last_conflict_mask;
                    pool[last_conflict_block] |= last_conflict_mask;
                    break;
                }
            }
        }
    }
}

__device__ void local_search(int graph_size, const block_t *edges, const int *weights, block_t *child, int color_count, block_t *pool, int *pool_count)
{
    block_t(*edges_p)[][TOTAL_BLOCK_COUNT - 1] = (block_t(*)[][TOTAL_BLOCK_COUNT - 1]) edges;
    block_t(*child_p)[][TOTAL_BLOCK_COUNT - 1] = (block_t(*)[][TOTAL_BLOCK_COUNT - 1]) child;

    int i, j, k, h, i_block;
    block_t i_mask, temp_mask;
    int competition;
    int conflict_count;
    block_t conflict_array[TOTAL_BLOCK_COUNT];

    // Search back and try placing vertices from the pool in the colors.
    for (i = 0; i < graph_size && (*pool_count) > 0; i++)
    {
        i_block = BLOCK_INDEX(i);
        i_mask = MASK(i);

        // Check if the vertex is in the pool.
        if (pool[i_block] & i_mask)
        {
            // Loop through every color.
            for (j = 0; j < color_count; j++)
            {
                // Count conflicts and calculate competition
                conflict_count = 0;
                competition = 0;
                for (k = 0; k < TOTAL_BLOCK_COUNT; k++)
                {
                    conflict_array[k] = (*edges_p)[i][k] & (*child_p)[j][k];
                    if (conflict_array[k])
                    {
                        temp_mask = conflict_array[k];
                        conflict_count += __popcountl(temp_mask);
                        for (h = 0; h < sizeof(block_t) * 8; h++)
                            if ((temp_mask >> h) & (block_t)1)
                                competition += weights[k * 8 * sizeof(block_t) + h];
                    }
                }

                // Place immediately if there are no conflicts.
                if (competition == 0)
                {
                    (*child_p)[j][i_block] |= i_mask;
                    pool[i_block] &= ~i_mask;
                    (*pool_count) += conflict_count - 1;
                    break;

                    /**
                     * If the total competition is smaller than the weight
                     * of the vertex in question, move all the conflicts to the
                     * pool, and place the vertex in the color.
                     */
                }
                else if (competition < weights[i])
                {
                    for (k = 0; k < TOTAL_BLOCK_COUNT; k++)
                    {
                        (*child_p)[j][k] &= ~conflict_array[k];
                        pool[k] |= conflict_array[k];
                    }

                    (*child_p)[j][i_block] |= i_mask;
                    pool[i_block] &= ~i_mask;
                    (*pool_count) += conflict_count - 1;
                    break;
                }
            }
        }
    }
}

__global__ void crossover_kernel(int graph_size, const block_t *edges, const int *weights, int color_num1, int color_num2, const block_t *parent1, const block_t *parent2, int target_color_count, block_t *child, int *child_color_count,
                                 int *uncolored, int *cross_result) // Adding a parameter for curandState to manage random number generation
{
    printf("Crossover kernel\n");
    // Allocate pointers for parent and child instead of using array syntax
    const block_t *parent1_p = parent1;
    const block_t *parent2_p = parent2;
    block_t *child_p = child;

    // Max number of colors of the two parents
    // color_num1 > color_num2 ? color_num1 : color_num2;

    // Allocate device memory for used color list
    __shared__ block_t used_color_list[2][MAX_COLOR];

    // Allocate device memory for used vertex list
    __shared__ block_t used_vertex_list[TOTAL_BLOCK_COUNT];
    int used_vertex_count = 0;

    // Allocate device memory for pool
    __shared__ block_t pool[TOTAL_BLOCK_COUNT];
    int pool_count = 0;

    int color1, color2, last_color = 0;
    int i, j;
    const block_t *chosen_parent_colors[2];

    for (i = 0; i < target_color_count; i++)
    {
        if (used_vertex_count < graph_size)
        {
            // Pick 2 random colors using curand
            color1 = get_rand_color(color_num1, i, used_color_list[0]);
            color2 = get_rand_color(color_num2, i, used_color_list[1]);
            chosen_parent_colors[0] = (color1 == -1) ? NULL : (parent1_p + color1 * TOTAL_BLOCK_COUNT);
            chosen_parent_colors[1] = (color2 == -1) ? NULL : (parent2_p + color2 * TOTAL_BLOCK_COUNT);

            merge_and_fix(graph_size, edges, weights, chosen_parent_colors, child_p + i * TOTAL_BLOCK_COUNT, pool, &pool_count, used_vertex_list, &used_vertex_count);
        }
        else if (pool_count == 0)
        {
            break;
        }

        search_back(graph_size, edges, weights, child, i, pool, &pool_count);
    }

    last_color = i;

    // If not all the vertices were visited, drop them in the pool
    if (used_vertex_count < graph_size)
    {
        for (j = 0; j < TOTAL_BLOCK_COUNT; j++)
        {
            pool[j] |= ~used_vertex_list[j];
        }
        pool[TOTAL_BLOCK_COUNT - 1] &= ((0xFFFFFFFFFFFFFFFF) >> (TOTAL_BLOCK_COUNT * sizeof(block_t) * 8 - graph_size));

        pool_count += (graph_size - used_vertex_count);
        used_vertex_count = graph_size;
        for (j = 0; j < TOTAL_BLOCK_COUNT; j++)
        {
            used_vertex_list[j] = 0xFF; // Mark all as visited
        }
    }

    local_search(graph_size, edges, weights, child, target_color_count, pool, &pool_count);

    int fitness = 0, temp_block;
    block_t temp_mask;
    if (pool_count > 0)
    {
        int color_num;
        for (i = 0; i < graph_size; i++)
        {
            temp_block = BLOCK_INDEX(i);
            temp_mask = MASK(i);
            if (pool[temp_block] & temp_mask)
            {
                color_num = curand(curand_state) % target_color_count; // Using curand for random selection
                child_p[color_num * TOTAL_BLOCK_COUNT + temp_block] |= temp_mask;

                if (color_num + 1 > last_color)
                {
                    last_color = color_num + 1;
                }

                fitness += weights[i];
            }
        }
    }
    else
    {
        fitness = 0;
    }

    *uncolored = pool_count;
    *child_color_count = last_color;
    *cross_result = fitness;

    printf("Fitness: %d | Uncolored: %d | Color Count: %d\n", fitness, pool_count, last_color);
}

int crossover(int graph_size, const block_t *edges, const int *weights, int color_num1, int color_num2, const block_t *parent1, const block_t *parent2, int target_color_count, block_t *child, int *child_color_count, int *uncolored)
{
    block_t *d_edges = NULL;
    int *d_weights = NULL;
    block_t *d_parent1 = NULL;
    block_t *d_parent2 = NULL;
    block_t *d_child = NULL;
    int *d_child_color_count = NULL;
    int *d_uncolored = NULL;
    int *d_cross_result = NULL;

    cudaError_t err = cudaMalloc(&d_edges, sizeof(block_t) * SIZE * TOTAL_BLOCK_COUNT);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for edges: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemcpy(d_edges, edges, sizeof(block_t) * SIZE * TOTAL_BLOCK_COUNT, cudaMemcpyHostToDevice);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not copy edges to device: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_weights, sizeof(int) * SIZE);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for weights: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemcpy(d_weights, weights, sizeof(int) * SIZE, cudaMemcpyHostToDevice);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not copy weights to device: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_parent1, sizeof(block_t) * TOTAL_BLOCK_COUNT * color_num1);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for parent1: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemcpy(d_parent1, parent1, sizeof(block_t) * TOTAL_BLOCK_COUNT * color_num1, cudaMemcpyHostToDevice);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not copy parent1 to device: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_parent2, sizeof(block_t) * TOTAL_BLOCK_COUNT * color_num2);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for parent2: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemcpy(d_parent2, parent2, sizeof(block_t) * TOTAL_BLOCK_COUNT * color_num2, cudaMemcpyHostToDevice);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not copy parent2 to device: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_child, sizeof(block_t) * TOTAL_BLOCK_COUNT * target_color_count);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for child: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemset(d_child, 0, sizeof(block_t) * TOTAL_BLOCK_COUNT * target_color_count);
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not set child memory to 0: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_child_color_count, sizeof(int));
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for child_color_count: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemset(d_child_color_count, 0, sizeof(int));
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not set child_color_count memory to 0: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_uncolored, sizeof(int));
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for uncolored: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemset(d_uncolored, 0, sizeof(int));
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not set uncolored memory to 0: %s\n", cudaGetErrorString(err));
        return -1;
    }

    err = cudaMalloc(&d_cross_result, sizeof(int));
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not allocate memory for cross_result: %s\n", cudaGetErrorString(err));
        return -1;
    }
    err = cudaMemset(d_cross_result, 0, sizeof(int));
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("Could not set cross_result memory to 0: %s\n", cudaGetErrorString(err));
        return -1;
    }

    crossover_kernel<<<1, 1>>>(graph_size, d_edges, d_weights, color_num1, color_num2, d_parent1, d_parent2, target_color_count, d_child, d_child_color_count, d_uncolored, d_cross_result);
    err = cudaGetLastError();
    err = cudaSuccess;
    if (err != cudaSuccess)
    {
        printf("CUDA kernel launch error: %s\n", cudaGetErrorString(err));
    }
    cudaDeviceSynchronize();

    int cross_result;
    cudaMemcpy(child, d_child, target_color_count * (TOTAL_BLOCK_COUNT) * sizeof(block_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(child_color_count, d_child_color_count, sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(uncolored, d_uncolored, sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(&cross_result, d_cross_result, sizeof(int), cudaMemcpyDeviceToHost);

    cudaFree(d_edges);
    cudaFree(d_weights);
    cudaFree(d_parent1);
    cudaFree(d_parent2);
    cudaFree(d_child);
    cudaFree(d_child_color_count);
    cudaFree(d_uncolored);
    cudaFree(d_cross_result);

    return cross_result;
}
